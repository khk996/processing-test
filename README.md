# processing-test
講義で久しぶりにprocessingについて触れたので、いろいろいじってみる

以下メモ
# 3omniwheels
せっかくだから復習の意味も込めて３輪オムニの速度制御を考えよう。入力はマウスでいいかな

出力は各オムニの速度成分なのだが、視覚的にするならば、全体の速度ベクトルが見えるようにし、各オムニの速度ベクトルも見えるようにする
#### 参考サイト

- [基本的な文法](https://qiita.com/yuichi92/items/1071deac965cd3801992)
- [三角関数](http://www.musashinodenpa.com/p5/index.php?pos=407)
- [色について](https://www.greenowl5.com/gprogram/processing/processing050.html)
- [回転について](http://9ryulabo.com/processing-learner/4-6.html)
- [テキストについて](https://www.d-improvement.jp/learning/processing/2011-b/03.html)

## まず、矢印を描画できるようにしよう

ウィンドウの中心からマウスの位置まで伸ばした矢印を描画する

どうやら単純に矢印を描画できないらしい（描画の仕方はpythonと同じ）なので、

ウィンドウの中心からマウスの位置までの距離を計測し、それを２:８に分割する。２割は三角形の描画に、８割は線の描画に使う。

三角形は各頂点の座標を指定する必要がある

一つはマウスの位置でよい。

ウィンドウの中心からマウスの位置までの距離を２：８に内分する点と

傾き（単位ベクトル）を求める。

その直線の内分点と垂直に交わる直線をだす。その直線上で、内分点からその距離の１０分の１だけ＋ーに進んだ位置を頂点とする

## 次に、オムニの描画を行う。
ウィンドウの中心から200離れたところに長方形の中心をおき、長方形は横100縦20にする。

一つは簡単、rect関数ですぐかける

残りの二つが少し面倒。直接座標を指定しないといけない
どうやら、回転させることができるみたい。

一応線対称なので、片方だけ求める

長方形の中心は、

(400-200*sin30, 300-200*cos30)

ここに長方形を生成し、回転させる。回転は原点中心？

思ったよりややこしいものだった。

回転はウィンドウ全体に反映されるが、rotate以降に反映される

# 詳細：

rotateとtranslateはそれ以降の座標系を異動・回転させるもの

なので、最初にウィンドウの中心を原点にするべきだった？

注意点として、マウスの座標を取り出すmouseX,mouseYには作用しない

また、以前の座標を使用したい場合は座標系の保存を事前にpushMatrixで行い、任意のタイミングでpopMatrixで読み出すことで座標系の初期化みたいなこともできる。



次に各オムニの速度を求める。各オムニは反時計回りを正とする。

速度ベクトルは(disX, disY)となっている。
![3輪オムニ速度モデル](https://user-images.githubusercontent.com/63386375/174957257-642a75b9-f82c-43de-8e01-3e7eb50e0852.png)
上記のように定義する。座標系はprocessingと合わせた

原点からオムニまでの距離を200、タイヤの半径を50とする。

全体の速度ベクトル（縦、横、旋回）は
$$V= \begin{pmatrix} V_x \\\ V_y \\\ V_{\theta }  \end{pmatrix}$$
となる。このとき、変換式は、
$$\begin{pmatrix} v_0 \\\ v_1 \\\  v_2 \end{pmatrix}=\begin{pmatrix} cos(180^o) & sin(0^o) & 200 \\\ cos(-60^o)&sin(60^o)&200 \\\ cos(60^o)&sin(-60^o)&200\end{pmatrix} \begin{pmatrix}v_x \\\ v_y \\\ v_{\theta }\end{pmatrix}$$
これで各オムニの速度がもとまる
今回は旋回を行わないことにする。
今回座標系を回転しているので、上の変換式そのまま出力すればよい

あとは、元の入力値（中心からマウスまでの距離）を各速度の合成値にすればよい
あとは細かいところ
オムニ描画を細かくする
各オムニの挙動を細かく描画する
